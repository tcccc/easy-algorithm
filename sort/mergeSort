//归并排序
//学习了树的概念，或者学习了堆排序，那再来学习归并排序，理解起来就会较快，实质上分隔出来的序列组合可以想象成一颗二叉树

//归并排序采用分而治之的思想，意思是把一个序列分成多个序列进行操作，在这里操作指的是排序，当然分而治之是一种思想，解决思路，并不一定特指排序。

//在某一个子序列排序完成后，达成有序状态，这是正是我们所需要的，在此之后我们需要合并序列，通常是2合1，意思当一个序列分成N个序列，在这n个序列达成有序
//状态后，我们进行合并，序列总数变为n/2或n/2+1，合并时，我们又要进行排序操作，但此时合并的2个子序列都已经是有序的，所以我们的操作极其高效

//大多数人对归并排序的讲解总是注重于思想，却对合并2个有序序列的操作只字不提，这里对合并2个有序序列简单讲解一下
// 假设我们采取升序排列
// 那么2个子序列必然在合并之前已经是升序排列好的了，也就是有序状态
// 我们的操作有2个，将2个子序列进行合并和 合并后的子序列依旧是有序状态
// 聪明的你已经想到，必然需要一块额外的空间来来减少我们操作的复杂性
//我们利用 temp 来保存我们排好序的数据，更贴切的说是我们挑选好的数据
//我们用指针或者变量记录2个准备进行合并的子序列的头 a,b
//arrrays[a]<arrays[b] 的情况下，temp[0]存入arrays[a]，然后a++
//继续进行比较，比较完成后我们可以筛选出至少min（a序列长度，b序列长度)的数据存入temp
//但这并不足够，我们需要判断a或者b是否已经到达他们所处子序列的尾部
//此时必然有一个已经达到尾部，另一个则可能没达到尾部，假设a未达到其子序列的尾部，则存在 a所处子序列长度-a 的数据未被写入temp
//而此段数据依旧是有序状态，且这段数据均大于我们已经写入temp的所有数据（我们假设进行升序排列），所以我们依次写入temp就足够了
//最后一步操作就是写入原数组

//计算时间复杂度
//对归并排序来说，他会进行分割，每一层元素总是n，需要比较n次，也就是时间复杂度为O(n)，
//总共分割为log2n层，这个很好理解，就是树的深度 2,n/2;  4,n/4;  8,n/8;  2^x=n， x=log2n
//所以总的时间复杂度为 nlog2n

//空间复杂度
//常常需要辅助存储n+log2n，O(n),但我们可以考虑优化为O(1)，我也不清楚为什么在网上看的代码总是开辟一块空间存放数据，为什么他们不进行交换从而减少空间的使用呢？
//交换一次需要写3次操作， 而开辟一块空间最终完成我们的排序需要写2次，不太清楚为什么非要额外空间来保存数据

//先写个大众版,空间复杂度为O(n)

public static void mergeSort(int[] arrays,int low,int high){
	int middle = (low+high)/2;
	if(low<high){                                   //如果小索引小于大索引，则存在继续分割的可能，进行分割，直至单个子序列含有元素有1时
		mergeSort(arrays,low,middle);              
		mergeSort(arrays,middle+1,high);
		mergeSort_body(arrays,low,middle,high);
	}
}
//合并操作，传入的2个子序列，low~middle，middle+1 ~high都是有序的
public static void mergeSort_body(int[] arrays,int low,int middle,int high){
	int[] temp = new int[high-low+1];
	int i = low;
	int j = middle+1;
	int k = 0;                            //对就是这，思考一下如何去掉这个temp数组
	while(i<= middle && j<= high){        //我们改一下 swap是个交换函数，简单改一下，swap（a，b）代表交换arrays[a],arrays[b]的数据
		if(arrays[i]<arrays[j])             //  while(i<= middle && j<= high){ 
			temp[k++] = arrays[i++];          //    if(arrays[i]<=arrays[j])
		else                                //       i++;
			temp[k++] = arrays[j++];          //      else  {  swap(i,j); i++;  }
	}                                     //    之后我们可以发现思路错了跳转到65行进行分析
	while(i<=middle){
		temp[k++]=arrays[i++];
	}
	while(j<=high){
		temp[k++]=arrays[j++];
	}
	for(int kk=0; kk< temp.length; kk++)
		arrays[kk+low] = temp[kk];
	
}

//刚刚我们考虑如何节省空间以求省去temp这个数组，通过编写代码，发现，思路是错误的
//原因在于，当若我们在2个子序列中进行排序，且不同额外空间，我们需要考虑这么一种情况:
// swap[i,j]后，前一个序列确实是有序的，但后一个序列确不是有序的了，因为我们只判断了arrays[i],arrays[j]的大小
//假设arrays[i]>arrays[j]，我们进行交换，前一个序列此时依旧有序，但arrays[j]却不一定小于arrays[j+1]
//如果我们必须这样，则必须用一个变量来保存交换后的位置，时间复杂度必然增加







