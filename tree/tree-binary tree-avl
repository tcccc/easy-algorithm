//在学习了二叉查找树之后，你会发现有的时候树分布非常不均衡，可能左边多，右边少，极端情况甚至可以退化成一个线性单链表
//在这种情况，查找的效率极低，n个节点，则有n层，或者说高度为n，查询的时间复杂度为n，简单爆炸

//很自然的，人们就会就想到怎么建立一个高度较为稳定的二叉树
//AVL就此诞生了，还蛮早的，上个世纪就有这东西了

//平衡二叉树（Balaned Binary Tree)也叫AVL树，如果我们记错的话，AVL取自两个作者的名字
//平衡二叉树要求左右两边的子树高度差不超过1，且任意一个子树均为平衡二叉树


//AVL相比普通二叉查找树的优点是显而易见的，AVL不会退化成线性单链表，高度基本为log2n，这意味着，查询操作的复杂度为很稳定，为log2n
//既然他比普通二叉查找树要求多了点，很自然的，我们创建AVL的过程是复杂一些的，插入跟删除节点就是会影响树的结构的，所有这些操作也会复杂一些
// AVL的难点就在于他增加节点及减少节点时所做的旋转操纵，他是如何保证自身结构的呢?


//这个旋转操作是总共有四种情况，其实按照对称来说可以分成两种情况 ll，lr，理解了两种另外两种是一样的道理
//左左   右右   左右  右左  想要直观点说明还是得靠图，没图不好说，这里放图片麻烦，而且用别人放到开源社区也不好意思对吧
//在脑海里构建一个模型吧，锻炼一下, ps：这里的高度指的是叶子到根节点最长路径

//想象root为根节点，r1为它的左子节，r2为它的右子节点，r1的高度为root.height-1   , r2的高度为root.height-3
//左右高度差超过1了，这时

//ll  左左的情况是  


//其实要我说就理解一种了其他三种就很容易就解决了，lr与rl不过是操作两次ll，rr而已，而ll，rr又是对称的关系






