

二叉树，可以为空，与树是有向图的定义冲突，不算树的一种，但二叉树符合其他方面树的所有定义，确切的讲，我个人觉得二叉树是树的一种，前面提到，单纯的树
几乎没有意义，而二叉树就是加个规则的一种树，比如最多2个子节点这样的规则
但从实现的角度来看，二叉树的接口方法及创建几乎都是自身开辟的，没有从树那里继承了任何方法

其实树的定义本身我就不知道该听信谁的，在一本较为出名的数据结构书中描述，树的节点数是大于等于0的，在网络上不少人持有的观点是树是有向图的一种情形，而
有向图节点数是大于0的

最关键的一个论点是，二叉树可以为空，而树不能为空这句话
这展现了，二叉树超出树的情形，如果上面的观点是正确的，那二叉树确实不是树
问题转化为树是否能为空
在百度百科中，树，空树这2个词条中居然存在以上两种描述都存在的情况



下面给出二叉树的定义：
包含n>=0个节点的有限集合
只存在一个root节点
每个节点之多有2个子节点，即左子节点，右子节点
从root节点可以到达任意一个叶子(即无子节点的节点）

满二叉树：除了 最后一层即离root节点最远的一层（你喜欢叫深度高度都行，甚至爬行度都行，反正就一个定义）外，其他节点均有子节点，属于二叉树的子集

完全二叉树：最后一层节点是连续集中在左边的，或者说从左边开始增加的，且去掉了最后一层后，是一个满二叉树


Binary Sort Tree 二叉查找树
二叉查找树继承自二叉树，但添加了一些规则—————左子节点小于父节点，右子节点大于父节点

首先定义一个二叉树

public class BinaryTree {
	
BinaryTree rightTree=null;
BinaryTree leftTree=null;
int value;
	
	public static void main(String[] args){
		int[] a={1,3,11,2,908,123,523,21,65634,123,75623,12316,534};
		BinaryTree root= new BinaryTree();
    root.value=a[0]；
		for(int i=1; i< a.length; i++)
			insert(root,a[i]);
		System.out.println(root.value);
		
	}
  public static void insert(BinaryTree root,int value){
    	if(null==root){
			root = new BinaryTree();
			root.value=value;
		
		}
		else if(value<root.value)
			insert(root.leftTree,value);
		else 
			insert(root.rightTree,value);
}
头疼，上面这段代码疯狂出问题，原因是没搞清楚引用的问题，问题有点大，一会另外弄一篇来说明，出问题的地方，是在插入方法中new对象的不合理

下面给出简单实现
public class BinaryTree {
	
BinaryTree rightTree=null;
BinaryTree leftTree=null;
int value;
	
	public static void main(String[] args){
		int[] a={1,3,11,2,908,123,523,21,65634,123,75623,12316,534};
		BinaryTree root= new BinaryTree();
		root.value=a[0];
		for(int i=1; i< a.length; i++)
			insert(root,a[i]);
		Traversal(root);
	}
  //插入节点
	public static BinaryTree insert(BinaryTree root,int value){
		
		if(null==root){
			root= new BinaryTree();
			root.value=value;
		}
		else if(value<root.value)
			root.leftTree=insert(root.leftTree,value);
		else 
			root.rightTree=insert(root.rightTree,value);
		return root;
	}
  //二叉树的中序遍历
	public static void Traversal(BinaryTree root){
		if(null==root)
			return ;
		Traversal(root.leftTree);
		System.out.print(root.value+"  ");
		Traversal(root.rightTree);
	}
  //二叉树的搜索
	public static boolean search(BinaryTree root,int value){
    if(null==root)
			return false;
		if(root.value==value) 
      return true;
		else if(value>=root.value)
			return search(root.rightTree,value);
		else 
			return search(root.leftTree,value);
	}
}





